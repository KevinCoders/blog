---
title: "IO类"
comments: true
share: true
date: 2016-03-13
toc: true
categories: c++
tags: c++
---

## IO类的基本内容

<img src="https://github.com/KevinSCoder/KevinSCoder.github.io/_posts/resource/1.jpg">

<img src="https://github.com/KevinSCoder/study/blob/master/resource/1.jpg">

* 从上图可以看出，iostream是读写流[^1]，fstream读写文件；从上图可以看出，fstream继承于iostream，因此发fstream也是读写流，只不过它的职责更窄，主要针对文件读写；
* cin是标准输入流对象，cout是标准输出流对象，这里的标准输入，就是指从键盘输入，标准输出，就是指输出到终端，由于c++中继承机制的实现，使我们不用考虑设备类型和字符大小的问题；
* c++的输入与输出包括以下三个部分：
  1. 对系统制定的标准设备的输入和输出，称为标准I/O（设备）; 
  2. 以磁盘文件为对象进行输入和输出，称为文件I/O（文件）; 
  3. 对内存中指定的空间进行输入和输出，称为串I/O（内存）; 

### 关于流的条件状态

 &emsp; &emsp; 一个流一旦发生错误，那么其后续的IO操作都会失败，只有一个流处于无错误状态时，我们才可以对其进行读写操作，因此代码应该在使用一个流之前检查它是否处于良好状态，代码如下：

```c++
while(cin >> word)

    //ok: 读操作成功,否则 >>返回false

```
&emsp; &emsp; 上面只是告诉了我们流是否有效，例如一个流失败了，我们不知道为什么失败，关于这一部分，我们可以使用iostate[^2], 也可以使用stream.eof()等函数判断；

[^1]: 流是c++中的抽象概念，我们可以认为流就是对象，如果从标准输出输入流中读写数据那么也就意味着从cout、cin中读写数据；
[^2]:iostate是一个机器无关类，提供了表达流状态的完整功能；

### 关于缓冲区

* 每个输出流都有一个缓冲区，用来保存程序读写的数据，如果我们执行文本打印操作，那么文本可能立即打印，也可能不立即打印，此时文本就被保存到了缓冲区；
* 文本缓冲区之所以存在，是因为设备的读写操作可能都很耗时，允许操作系统将多个输出操作合二为一可以带来性能提升；
* 如果我们不想使用缓冲，那么就必须进行缓冲刷新，以下方式可以导致刷新：

> 1. 程序正常结束；
> 2. 缓冲区满时；
> 3. 使用操作符endl；
> 4. 使用flush；

Note：如果程序崩溃，那么输出缓冲区是不会被刷新的，可能存在这样一种情况：我们通过输出调试信息调试程序，但程序正好崩溃，但实际输出可能已经执行，之所以没有打印只是因为没有缓冲区没有被刷新而已；

### 文件输入输出

&emsp; &emsp; ifstream、ofstream都继承自fstream，分别对应标准输入输出流中的cin、cout，cin是以键盘作为作为标准输入，ifstream是以文件作为输入，换句话说，就是读取文件；同理，cout是以终端作为标准输出，ofstream是以文件作为输出，也就是把数据写入文件；

## 编写自己的输入输出运算法（14章）

## 控制输出格式以及文件的随机访问（17章）

参考链接：<a href = "https://www.cnblogs.com/tianzeng/p/9038810.html">C++的流</a>
